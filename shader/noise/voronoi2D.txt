// Copyright (c) 2021 Lachlan McDonald
// This work is licensed under the MIT License (MIT)
// https://github.com/lachlanmcdonald/magicavoxel-shaders
//
// This script utilises or modifies code from other projects or publications.
// Please see the attributions below for more information:
//
// 1. Copyright (c) 2011 Stefan Gustavson <https://github.com/ashima/webgl-noise>
//    MIT License (MIT)
//    https://github.com/ashima/webgl-noise/blob/master/LICENSE
//
// xs noise/cellular3D [Mode] [Scale] [Jitter] [Noise] [Power] [Cavity] [Seed] [Tile X] [Tile Y] [Tile Z]
//
// xs_begin
// author : '@lachlanmcdonald'
// arg : { name = 'Mode'  var = 'm_mode'  range = '0 5'  value = '0'  step = '1'  precision = '0' }
// arg : { name = 'Scale'  var = 'm_scale'  range = '1 100'  value = '24'  step = '1'  precision = '0' }
// arg : { name = 'Jitter'  var = 'm_jitter'  range = '-100 100'  value = '100'  step = '5'  precision = '0' }
// arg : { name = 'Noise'  var = 'm_noise'  range = '0 100'  value = '0'  step = '1'  precision = '0' }
// arg : { name = 'Power'  var = 'm_power'  range = '0 10'  value = '1'  step = '0.05'  precision = '2' }
// arg : { name = 'Cavity'  var = 'm_cavity'  range = '0 100'  value = '50'  step = '1'  precision = '0' }
// arg : { name = 'Seed'  var = 'm_seed'  range = '1 100'  value = '1'  step = '1'  precision = '0' }
// arg : { name = 'Tile X'  var = 'tile_x'  range = '0 40'  value = '0'  step = '1'  precision = '0' }
// arg : { name = 'Tile Y'  var = 'tile_y'  range = '0 40'  value = '0'  step = '1'  precision = '0' }
// arg : { name = 'Tile Z'  var = 'tile_z'  range = '0 40'  value = '0'  step = '1'  precision = '0' }
// xs_end

int mode = int(m_mode);
float noise = m_noise / 100.0;
float jitter = m_jitter / 100.0;
float cavity = m_cavity / 100.0;
vec3 tile = vec3(tile_x, tile_y, tile_z) * i_volume_size;

const mat2 myt = mat2(0.12121212, 0.13131313, -0.13131313, 0.12121212);
const vec2 mys = vec2(1e4, 1e6);

vec2 rhash(vec2 uv) {
  uv *= myt;
  uv *= mys;
  return fract(fract(uv / mys) * uv);
}

vec3 hash(vec3 p) {
  return fract(sin(vec3(dot(p, vec3(1.0, 57.0, 113.0)), dot(p, vec3(57.0, 113.0, 1.0)), dot(p, vec3(113.0, 1.0, 57.0)))) * 43758.5453);
}

vec3 voronoi(vec3 x) {
	vec3 p = floor(x);
	vec3 f = fract(x);

	float id = 0.0;
	vec2 res = vec2(100.0);

	for (int k = -1; k <= 1; k++) {
		for (int j = -1; j <= 1; j++) {
			for (int i = -1; i <= 1; i++) {
				vec3 b = vec3(float(i), float(j), float(k));
				vec3 r = vec3(b) - f + hash(p + b);
				float d = dot(r, r);

				float cond = max(sign(res.x - d), 0.0);
				float nCond = 1.0 - cond;

				float cond2 = nCond * max(sign(res.y - d), 0.0);
				float nCond2 = 1.0 - cond2;

				id = (dot(p + b, vec3(1.0, 57.0, 113.0)) * cond) + (id * nCond);
				res = vec2(d, res.x) * cond + res * nCond;

				res.y = cond2 * d + nCond2 * res.y;
			}
		}
	}

	return vec3(sqrt(res), abs(id));
}

float pal(float p) {
	float f = floor(mix(0.0, float(i_num_color_sels), p));
	return color_sel(f);
}

float map(vec3 v) {
	vec3 uv = floor(v) / i_volume_size + tile;
	vec3 d = voronoi(v * m_scale);

	return pal(d.x / d.y);
}
