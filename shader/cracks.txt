// Copyright (c) 2023 Lachlan McDonald
// This work is licensed under the MIT License (MIT)
// https://github.com/lachlanmcdonald/magicavoxel-shaders
//
// This script utilises or modifies code from other projects or publications.
// Please see the attributions below for more information:
//
// 1. Copyright (c) 2013 Inigo Quilez <https://iquilezles.org/>
//    MIT License (MIT)
//
// xs noise/cellular2D [Mode] [Scale] [Jitter] [Noise] [Power] [Steps] [Seed] [Tile X] [Tile Y]
//
// xs_begin
// author : '@lmcdx.bsky.social'
// arg : { name = 'Scale'  var = 'm_scale'  range = '2 32'  value = '20'  step = '0.25'  precision = '1' }
// arg : { name = 'Edge'  var = 'm_edge'  range = '1 100'  value = '50'  step = '1'  precision = '0' }
// xs_end

vec2 hash2(vec2 p) {
	return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);
}

vec3 voronoi(vec3 x) {
    vec2 n = floor(x.xy);
    vec2 f = fract(x.xy);

    vec2 mg, mr;
    float md = 8.0;
    for (int j =- 1; j <= 1; j++) {
        for (int i =- 1; i <= 1; i++) {
            vec2 g = vec2(float(i), float(j));
            vec2 o = hash2(n + g);

            o = 0.5 + 0.5 * sin(x.z + 6.2831 * o);

            vec2 r = g + o - f;
            float d = dot(r, r);

            if (d < md) {
                md = d;
                mr = r;
                mg = g;
            }
        }
    }

    md = 8.0;
    for (int j =- 2; j <= 2; j++) {
        for (int i =- 2; i <= 2; i++) {
            vec2 g = mg + vec2(float(i), float(j));
            vec2 o = hash2(n + g);

            o = 0.5 + 0.5 * sin(x.z + 6.2831 * o);

            vec2 r = g + o - f;

            if (dot(mr - r,mr - r) > 0.00001) {
                md = min(md, dot(0.5 * (mr + r), normalize(r - mr)));
            }
        }
    }

    return vec3(md, mr);
}

float map(vec3 v) {
	vec3 p = v / i_volume_size;
	vec3 c = voronoi(p * m_scale);
	return c.x < mix(0.01, 0.2, m_edge / 100.0) ? i_color_index : 0.0;
}
